# ### CASPIAN CALIBRATION SCRIPT for Corbicula
rm(list=ls())
graphics.off()
library(CASPIAN)
library(BayesianTools)
library(foreach)
library(doParallel)
library(PresenceAbsence)

mainDir<-"~/../Desktop/Corbicula"
# mainDir<-"/home/hanno/Bioinvasion/EBAspread/Model"
setwd(mainDir)
unlink(dir(mainDir, pattern = "CASPIAN_", full.names = TRUE), recursive = TRUE)

load("PreCalibration.Rdata")

# build parameter matrix
parameters<-ParMatrix(par_att0_Roads,par_att0_Railways,par_att1,par_att2,par_att3,
                      par_air0_Roads,par_air0_Railways,par_air1,par_air2,
                      par_nat1,par_nat2,par_est_T,par_cont,par_pall,
                      par_nat_a,par_nat_b,par_ball,
                      par_a,par_c1,par_g,par_c2,par_b,par_c3,par_est_W)

# get default values
defaultValues <- parameters

#select which parameters to calibrate
parNames <- c("nat_a","nat_b","ball1","beta","c3","estW")

parSel <- c()
for (i in parNames) parSel <- c(parSel, grep(i, colnames(defaultValues)))
parValues <- c(defaultValues[parSel])

npar <- length(parValues)

# for (i in ls()[grep("errpar", ls())]) defaultValues <- c(defaultValues, get(i))  #Commented, avoid likelihood sd if possible

# get calibrated parameters range
parRange<-data.frame(name=parNames,
                     min= c(6,0.4,
                            10^3,
                            3.15 * 10^-4, 2.3,
                            0.7),
                     max= c(13,3.5,
                            10^5,
                            3.15,3,
                            0.99))

# for (i in rownames(parameterStandard)) {
#   defaultValues[i] <- parameterStandard[rownames(parameterStandard) ==
#                                           i]
# }

#define prior range
PriorRange<-data.frame(name=parNames,
                       min_range=parRange$min[parRange$name%in%parNames],
                       default=parValues,
                       max_range=parRange$max[parRange$name%in%parNames])

# build priors

prior.min <- c()
prior.max <- c()

for (i in 1:npar) {
  prior.min[i] <- c(PriorRange$min_range[which(PriorRange$name ==
                                                 parNames[i])])
  prior.max[i] <- c(PriorRange$max_range[which(PriorRange$name ==
                                                 parNames[i])])
}

# prior <- createUniformPrior(lower = prior.min, upper = prior.max, best = parValues)
ms<-apply(cbind(PriorRange$min_range,PriorRange$max_range),1,median)
prior <- createTruncatedNormalPrior(lower = prior.min, upper = prior.max,
                                    mean = parValues, sd= abs(ms*0.3)
)

#define likelihood function -PCC based
AUC_CASPIAN <- function(pars) {
  #  pars<-BCsetup$prior$sampler(1)
  if (is.vector(pars))  pars = matrix(pars, nrow = 1)
  
  p <- matrix(NA, nrow = nrow(pars), ncol = length(defaultValues))
  
  for (i in 1:nrow(pars)) p[i, ] <- suppressWarnings(createMixWithDefaults(pars[i,
                                                                                1:ncol(pars)], defaultValues, parSel)
  )
  colnames(p) <- colnames(defaultValues)
  # nerr <- length(grep("errpar", colnames(p)))
  
  # pars <- p[, -tail(1:ncol(p), nerr)]
  # ifelse(is.matrix(pars), yes = pars <- ListPar(pars),
  #        no = pars <- ListPar(t(as.matrix(pars))))
  
  # ifelse(parallelOption == FALSE, yes = parameterList <- pars[[1]],
  #        no = parameterList <- pars)
  #
  load(init_file)
  # load(netw_file)
  assign(x="pars",value=pars,envir = .GlobalEnv)
  invisible(capture.output(
    outputCASPIAN <- WaterSpreadModel(parameters=p,init_obj=init_water_data,
                                      Water_netw_data=Water_netw_data,
                                      traffic_type=traffic_type_W,
                                      init_coords=init_coords_W, num_iter=num_iter_W,max_dist = max_dist_W,
                                      incl_hullfouling=incl_hullfouling,incl_natural_water=incl_natural_water,incl_ballast=incl_ballast,
                                      Port_time=Port_time,Paint_time=Paint_time,
                                      iter_save = iter_save_W,plot_funct_rel=plot_funct_rel
    )
  ))
  
  #
  # if (parallelOption == FALSE) {
  #   parameterList <- pars
  #   outputLPJ <- list(outputLPJ)
  #
  nruns <- 1
  # } else nruns <- length(parameterList)
  #
  AUCs <- c()
  
  for (nparticles in 1:nruns) {
    AUC <- c()
    for (nsteps in 1:length(outputCASPIAN)){
      
      predicted <- outputCASPIAN[[nsteps]][,c("ID","Pinv")]
      observed <- CompleteInvasionData[[nsteps]]
      llobj <- merge(observed, predicted, all = FALSE,
                     by = "ID")
      #     AUC here
      colnames(llobj)<-c("ID","Observed","CASPIAN")
      InitLinks<-which(llobj$ID%in%init_water_data$init_segm)
      if (length(InitLinks)!=0) { llobj<-llobj[-InitLinks,]} 
      options(warn = -1)
      singleAUC<-presence.absence.accuracy(llobj, threshold = 0.5, find.auc = TRUE, st.dev = FALSE, which.model=1,na.rm = T)$PCC
      options(warn = 0)
      # print(paste(nsteps, singleAUC,sep=" "))
      
      singleAUC<-c((singleAUC-1)*100)
      
      AUC<- sum(AUC,singleAUC,na.rm = T)
    }
    
    AUCs[nparticles] <- AUC
  }
  
  unlink(dir(mainDir, pattern = "CASPIAN_", full.names = TRUE), recursive = TRUE)
  # sink("AUCs.txt",append = TRUE)
  # print(AUCs)
  # sink()
  
  return(AUCs)
  
}

#create BCsetup and define calibration settings
numChains<-3
numInternalParallel<-3

iterations <- 10^5  
BCsetup <- createBayesianSetup(AUC_CASPIAN, prior,
                               parallel = FALSE, names = parNames)

start <- BCsetup$prior$sampler(9)
colnames(start) <- parNames
DEStart <- list(start[1:3, ] , start[4:6, ], start[7:9,])


#run calibration
cat("\n Calibration started ", as.character(Sys.time()) , "\n")
T1<-proc.time()

numCores<-numChains
 cl <- makeCluster(numCores, type = "SOCK")
 registerDoParallel(cl)

 resDREAMparallel<-foreach(n = 1:numChains, .packages = c("CASPIAN","BayesianTools","PresenceAbsence") ) %dopar% {

   BCsetup <- createBayesianSetup(AUC_CASPIAN, prior, parallel = FALSE, names = parNames)

 BCsettings <- list(iterations = iterations, nrChains = 1,
                      startValue = DEStart[[n]], consoleUpdates = 1)
   sink(paste0("ChainNr",n,".txt"))
   res <- runMCMC(BCsetup,
                  sampler = "DREAMzs", settings = list(iterations = iterations, nrChains = 1,
                                                    startValue = DEStart[[n]], consoleUpdates = 1))
   sink()
   return(res)
 }
 stopCluster(cl)

resDREAM<-createMcmcSamplerList(list(resDREAMparallel[[1]],resDREAMparallel[[2]],resDREAMparallel[[3]]))

#sink("ChainNr1.txt")
# resDREAM <- runMCMC(BCsetup,
#                     sampler = "DREAMzs", settings = list(iterations = iterations, nrChains = numChains, startValue = DEStart[[1]], consoleUpdates = 1))
#sink()

T2<-proc.time()
cat("\n Calibration completed ", as.character(Sys.time()) , "\n")
print(T2-T1)


cat("\n Calculating Maximum Likelihood model output \n")
bestPars<- suppressWarnings(createMixWithDefaults(t(as.matrix(MAP(resDREAM)$parametersMAP)), defaultValues, parSel))
# iter_save_W<-c(1, 6, 12, 18, 24, 30, 36, 42, 48)
load(init_file)

outputCASPIAN <- WaterSpreadModel(parameters=bestPars,init_obj=init_water_data,
                                  Water_netw_data=Water_netw_data,
                                  traffic_type=traffic_type_W,
                                  init_coords=init_coords_W, num_iter=num_iter_W,max_dist = max_dist_W,
                                  incl_hullfouling=incl_hullfouling,incl_natural_water=incl_natural_water,incl_ballast=incl_ballast,
                                  Port_time=Port_time,Paint_time=Paint_time,
                                  iter_save = iter_save_W,plot_funct_rel=plot_funct_rel
)

save.image("CalibrationResults.rData")

cat("\n Plotting Results \n")
# for (i in iter_save_T){
#   plotResults(list_results = outputCASPIAN[as.character(i)],shapeObj = Ship_Travel_Netw,save_plot = FALSE,save_dir = mainDir)
#   #  points(data_coords_senecio[iter<=i,1:2],col="blue",cex=2,lwd=4)
#   #  plot(AmbrosiaSubset,add=T)
#   scalebar(d = 5,type = "bar",divs = 4,lonlat = TRUE,label = c(0,"Km",5))
#   savePlot(filename=paste0(mainDir,"/SpreadModel_map_",i,".png"),
#            type="png",
#            device=dev.cur())
#   dev.off()
# }
pdf("traceplot.pdf",width = 7,height = 10)
plot(resDREAM,parametersOnly=FALSE)
dev.off()
pdf("correlationplot.pdf",width = 7,height = 10)
correlationPlot(resDREAM)
dev.off()
sink("ResultSummary.txt")
summary(resDREAM)
sink()
pdf("PriorsVsPosteriors.pdf",width = 10,height = 10)
par(mfrow=c(3,3))
SampleChain<-getSample(resDREAM,parametersOnly = TRUE,numSamples = 1000)
SamplePrior<-BCsetup$prior$sampler(1000)
for (i in 1:npar) {
  densPrior<-density(SamplePrior[,i])
  densChain<-density(SampleChain[,i])
  hist(SamplePrior[,i],main=parNames[i],freq = FALSE,
       border = "white",
       xlab="Parameter value",
       xlim=c(BCsetup$prior$lower[i],BCsetup$prior$upper[i]),ylim=c(0,max(c(densChain$y,densPrior$y))))
  lines(densPrior$y~densPrior$x)
  lines(densChain$y~densChain$x,col="red")
}
dev.off()

pdf("GoodnessOfFit.pdf",width = 7,height = 7)
predicted <- outputCASPIAN[[tail(names(outputCASPIAN),1)]][,c("ID","Pinv")]
observed <- InvasionData[[tail(names(outputCASPIAN),1)]]
GoF <- merge(observed, predicted, all = FALSE,
             by = "ID")

colnames(GoF)<-c("ID","Observed","CASPIAN")
InitLinks<-which(GoF$ID%in%init_water_data$init_segm)
if (length(InitLinks)!=0) { GoF<-GoF[-InitLinks,]} 
presence.absence.summary(GoF, threshold = 0.5, which.model=1,na.rm = T)
dev.off()

cat("\n Done \n")



#####################
# restart calibration
#####################

# 
# 
# cat("\n Calibration restarted ", as.character(Sys.time()) , "\n")
# T1<-proc.time()
# 
# iterations<-1*(10^5)
# numCores<-numChains*numInternalParallel
# # BCsetup <- createBayesianSetup(Auc_CASPIAN, prior,
# #                                parallel = numInternalParallel, names = parNames)
# 
# # cl <- makeCluster(numCores, type = "SOCK")
# # registerDoParallel(cl)
# #
# # resDREAMparallel<-foreach(n = 1:numChains, .packages = c("CASPIAN","BayesianTools") ) %dopar% {
# #
# #   BCsetup <- createBayesianSetup(likelihoodCASPIAN, prior, parallel = numInternalParallel, names = parNames)
# #
# #   # BCsettings <- list(iterations = iterations, nrChains = 1,
# #   #                    startValue = DEStart[[n]], consoleUpdates = 1)
# #   sink(paste0("ChainNr",n,".txt"))
# #   res <- runMCMC(BCsetup,
# #                  sampler = "DEzs", settings = list(iterations = iterations, nrChains = 1,
# #                                                    startValue = DEStart[[n]], consoleUpdates = 1))
# #   sink()
# #   return(res)
# # }
# # stopCluster(cl)
# 
# #resDREAM<-createMcmcSamplerList(list(resDREAMparallel[[1]],resDREAMparallel[[2]],resDREAMparallel[[3]]))
# 
# sink("ChainNr1.txt",append = T)
# resDREAM_2 <- runMCMC(bayesianSetup = resDREAM,
#                       sampler = "DEzs", settings = list(iterations = iterations, nrChains = numChains, consoleUpdates = 1))
# sink()
# 
# T2<-proc.time()
# cat("\n Calibration completed ", as.character(Sys.time()) , "\n")
# print(T2-T1)
# 
# save.image("CalibrationResults2.rData")
# 
# cat("\n Plotting Results \n")
# #plotResults(list_results = outputCASPIAN,shapeObj = SenecioRoad[SenecioRoad@data$Typ%in%netw_type,],save_plot = TRUE,save_dir = mainDir)
# 
# pdf("traceplot2.pdf",width = 7,height = 10)
# plot(resDREAM_2,parametersOnly=FALSE)
# dev.off()
# pdf("correlationplot2.pdf",width = 7,height = 10)
# correlationPlot(resDREAM_2)
# dev.off()
# sink("ResultSummary2.txt")
# summary(resDREAM_2)
# sink()
# pdf("PriorsVsPosteriors2.pdf",width = 10,height = 10)
# par(mfrow=c(3,3))
# SampleChain<-getSample(resDREAM_2,parametersOnly = TRUE,numSamples = 1000)
# SamplePrior<-BCsetup$prior$sampler(1000)
# for (i in 1:npar) {
#   densPrior<-density(SamplePrior[,i])
#   densChain<-density(SampleChain[,i])
#   hist(SamplePrior[,i],main=parNames[i],freq = FALSE,
#        border = "white",
#        xlab="Parameter value",
#        xlim=c(BCsetup$prior$lower[i],BCsetup$prior$upper[i]),ylim=c(0,max(c(densChain$y,densPrior$y))))
#   lines(densPrior$y~densPrior$x)
#   lines(densChain$y~densChain$x,col="red")
# }
# dev.off()
# 
# pdf("GoodnessOfFit2.pdf",width = 7,height = 7)
# predicted <- outputCASPIAN[[tail(names(outputCASPIAN),1)]][,c("ID","Pinv")]
# observed <- InvasionData[[tail(names(outputCASPIAN),1)]]
# GoF2 <- merge(observed, predicted, all = FALSE,
#               by = "ID")
# colnames(GoF2)<-c("ID","Observed","CASPIAN")
# 
# plot(CASPIAN~Observed,data=GoF2,pch=16)
# abline(0,1,col="red",lty=2)
# dev.off()
# 
# pdf("PredVsObs2.pdf",width = 7,height = 7)
# boxplot(CASPIAN~Observed, data=GoF2, main = ncol(GoF2)[3],pch=16,xlab="Observed",ylab="Predicted")
# dev.off()
# 
# cat("\n Done \n")
# 
# save.image("CalibrationResults2.rData")
# 
# 
# 
